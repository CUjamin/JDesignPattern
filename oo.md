
单一责任原则（SRP）

    就一个类而言，应该仅有一个引起它变化的原因。
    软件设计真正要做的很多内容，就是发现职责并把那些责任相互分离
    如果你能想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责
    
开放关闭原则

    软件实体（类、模块、函数等等），应该可以扩展，但是不可修改。
    对于扩展是开放的（Open for extension）
    对于更改是封闭的（Closed for modification）
    设计人员必须先猜测出最有可能的变化类型，然后构造抽象来隔离这些变化
    面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码
    
里氏代换原则（LSP）

    一个软件实体如果使用的是一个父类的话，那么一定适用于子类，
    而且他察觉不出父类对象和子类对象的区别。
    在软件里面，把父类替换成子类，程序的行为没有变化。
    （企业不能继承鸟，因为企鹅不会飞）
    
依赖反转原则
    
    高层模块不应该依赖低层模块，两个都应该依赖抽象（主板与内存的关系，通过标准插槽连接）。
    抽象不应该依赖细节，细节应该依赖抽象（针对接口编程，不要针对实现编程）。
    
    程序中所有依赖关系都是终止于抽象类或者接口-->面向对象设计。
    反之：面向过程设计。
    
    
迪米特法则（LoD）

    最少知识原则
    如果两个类不必彼此直接通讯，那么这两个类就不应当发生直接的相互作用。
    如果其中一个类需要调用另一个类的某一个方法的，可以通过第三者转发这个方法。
    
    在类的结构设计上，每一个类都应当尽量降低成员的访问权限。
    类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。
    
    
    
    